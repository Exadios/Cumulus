/************************************************************************
 **
 **   Copyright (c):  2006-2014 by Axel Pauli, kflog.cumulus@gmail.com
 **
 **   This file is distributed under the terms of the General Public
 **   License. See the file COPYING for more information.
 **
 **   $Id$
 **
 *************************************************************************
 **
 **   welt2000.h
 **
 **   This class is part of Cumulus. It provides an interface to be
 **   able to read data from a welt2000.txt ASCII file, created by
 **   Michael Meier and maintained by Howard Mills and Mike KÃ¶ster
 **
 **   http:http://www.segelflug.de/vereine/welt2000/download/WELT2000.TXT
 **
 **   The file source contains data about airfields, glider fields,
 **   outlandings and turn points in a proprietary ASCII format. Only
 **   the information about airfields, gliderfields, ultralight
 **   fields and outlandings are extracted by this class from the source
 *    and put into the related lists (airfield, glider or outlanding list)
 **   of Cumulus. Furthermore a compiled binary version of the extracted
 **   data is created during parsing, usable at a next run of Cumulus
 **   for a faster startup. Because Welt2000 supports only three kinds
 **   of airfields (airfield, gliderfield, ul-field) but Cumulus some
 **   more, a configuration file has been introduced, which allows an
 **   additional mapping to other map elements of Cumulus. Furthermore
 **   it provides a country filter mechanism. See later on for more
 **   information about the configuration file possibilities.
 **
 **   To start the load of Welt2000 data, the method load has to be
 **   called. It will put all extracted data into the passed lists. The
 **   load method will search for a source file with name welt2000.txt
 **   resp. a compiled file with the name welt2000.txc in the default
 **   map directories of Cumulus. The first found file is always
 **   taken. If a compiled file exists, different checks will be
 **   executed, if it is usable for reloading:
 **
 **   a) Internal header data magic, version, type, ... are controlled.
 **      Problems will cause a reparsing of the source file.
 **
 **   b) Creation time is checked against source and config file's
 **      modification time. If one of them is younger a reparsing of the
 **      source file is started.
 **
 **   c) If the compiled file was generated by using 1000Km radius, home
 **      position change is checked. If true, a reparsing of the source
 **      file is started.
 **
 **   d) If map projection type or data have been changed, a reparsing
 *       of the source file is started.
 **
 **   If a source file parsing is necessary, it is first checked, if a
 **   new original source file has been installed. Such a file
 **   contains more as we need, a lot of turn points and out commented
 **   lines. If true then an extracted version will be created from it
 **   and written back under the same file name with a specific header
 **   for Cumulus. That will reduce the file size over 50% (3MB to
 **   1.4MB). This compressed file is then the base for all parsing
 **   calls so long no new source is installed. Because all data for
 **   the whole world is contained in one file, we need a mechanism to
 **   extract only a subset from it and to protect Cumulus for
 **   overloads (e.g. memory overflow). There are foreseen different
 **   possibilities for filtering:
 **
 **   a) In the configuration area of Cumulus the user can define either
 **      a country filter or a radius around his home position. These
 **      items do overwrite the items in the configuration file.
 **
 **   b) A configuration file contains a country filter rule. Only the
 **      listed countries will be considered during parsing.
 **
 **   c) If no country filter rule is defined, then all data are used
 **      inside 500Km radius around the home position. I hope that is an
 *       useful compromise and protects Cumulus for memory overflows.
 **
 **   Now some remarks about the configuration file and its
 **   content. Its name is welt2000.conf. The expected location is the
 **   same where the welt2000.txt file is to find. It can contain
 **   entries for country filtering and also entries for additional
 **   mappings. A comment line starts with a hashmark or a dollar sign
 **   and ends with the newline sign.
 **
 **   A country filter rule in the welt2000.conf file has to be defined
 **   in the following way:
 **
 **   FILTER countries=de,pl,cz,nl
 **
 **   Different countries can be defined within one rule but they have
 **   to be separated by commas. The definition of several filter
 **   lines is also possible. Country abbreviations are coded according
 **   to ISO-3166. See in the header of welt2000.txt file which
 **   countries are inside to find and how is their spelling.
 **
 **   Furthermore the configuration file supports the remapping of single
 **   airfield entries to other map elements of cumulus. The
 **   welt2000.txt file knows only three different types (airfield,
 **   glider field, ul field). Cumulus supports more. There are two
 **   possibilities for a remapping available:
 **
 **   a) A short name (first six left standing characters of definition)
 **      can be remapped according to the following rule:
 **
 **      MAP_SHORT_NAME <short-name>=<new-map-element-of-cumulus>
 **
 **   b) An ICAO identifier can be remapped according to the following rule:
 **
 **      MAP_ICAO <icao-sign>=<new-map-element-of-cumulus>
 **
 **   The supported Cumulus map elements are:
 **
 **   [IntAirport|Airport|MilAirport|CivMilAirport|Airfield|ClosedAirfield|
 **    CivHeliport|MilHeliport|AmbHeliport|Gliderfield|UltraLight|HangGlider]
 **
 **   Against the original compiled version of a Cumulus airfield
 **   file, the elements of a compiled Welt2000 file were further
 **   reduced. All redundant entries with no information were removed
 **   from the output. Therefore the compiled file is incompatible
 **   with the kfc files but slimmer. To avoid confusion with the
 **   existing kfc files, which are derived from kfl, the extension
 **   .txc was chosen to show that this file is derived from a .txt
 **   file.
 **
 ***********************************************************************/

#ifndef _welt2000_h
#define _welt2000_h

#include <QDateTime>
#include <QList>
#include <QMap>
#include <QMutex>
#include <QPoint>
#include <QRect>
#include <QString>
#include <QStringList>

#include "airfield.h"
#include "basemapelement.h"

/**
 * \class Welt2000
 *
 * \author Axel Pauli
 *
 * \brief Class to read, parse and filter a Welt2000 file.
 *
 * This class can read, parse and filter a Welt2000 file and store its content
 * in a binary format.
 *
 * \date 2006-2014
 *
 * version $Id$
 *
 */

class Welt2000
{
 public:

  /**
   * Constructor
   */
  Welt2000();

  /**
   * Destructor
   */
  virtual ~Welt2000();

  /**
   * Searches on default places a Welt2000 file and load it. A source
   * can be the original ASCII file or a compiled version of it. The
   * results are put in the passed lists.
   *
   * @param airfieldList All airfields have to be stored in this list
   * @param gliderfieldList All glider fields have to be stored in this list
   * @param outlandingList All outlanding fields have to be stored in this list
   * @return true (success) or false (error occurred)
   */
  bool load( QList<Airfield>& airfieldList,
             QList<Airfield>& gliderfieldList,
             QList<Airfield>& outlandingList );

  /**
   * Checks for a Welt2000 update by comparing headers of current installed
   * Welt2000 file and the newer file.
   *
   * \return true, if an update shall be made otherwise false
   */
  bool check4update();

  /**
   * Checks, if a Welt2000 file is to find in the airfield directories.
   *
   * \return true, if a file is found otherwise false
   */
  bool check4File();

 private:

  /**
   * Parses the passed file in Welt2000 format and put the appropriate
   * entries in the related lists.
   *
   * @param path Full name with path of Welt2000 file
   * @param airfieldList All airfields have to be stored in this list
   * @param gliderfieldList All glider fields have to be stored in this list
   * @param outlandingList All outlanding fields have to be stored in this list
   * @param doCompile Creates a binary file of the parser results,
   *                  if the flag is set to true. Default is false.
   * @return true (success) or false (error occurred)
   */
  bool parse( QString& path,
              QList<Airfield>& airfieldList,
              QList<Airfield>& gliderfieldList,
              QList<Airfield>& outlandingList,
              bool doCompile=false );

  /**
   * The passed file has to be fulfill a Welt2000 file format. All
   * not relevant entries, like turn points, will be filtered
   * out. The content of the old file is overwritten with the
   * filtered results to save disk space.
   *
   * @param path Full name with path of Welt2000 file
   * @return true (success) or false (error occurred)
   */
  bool filter( QString &path );

  /**
   * Read all entries from the configuration file related to Welt2000.
   *
   * @param path Full name with path of Welt2000 configuration file
   * @return true (success) or false (error occurred)
   */
  bool readConfigEntries( QString &path );

  /**
   * Read the content of a compiled file and put it into the related
   * lists.
   *
   * @param path Full name with path of Welt2000 binary file
   * @param airfieldList All airports have to be stored in this list
   * @param gliderfieldList All gilder fields have to be stored in this list
   * @param outlandingList All outlanding fields have to be stored in this list
   * @return true (success) or false (error occurred)
   */
  bool readCompiledFile( QString &path,
                         QList<Airfield>& airfieldList,
                         QList<Airfield>& gliderfieldList,
                         QList<Airfield>& outlandingList );

  /**
   * Gets the header data of a compiled file and put it in the class
   * variables.
   *
   * @param path Full name with path of Welt2000 binary file
   * @return true (success) or false (error occurred)
   */
  bool setHeaderData( QString &path );

 private:

  QMap<QString, BaseMapElement::objectType> c_baseTypeMap;

  // Maps used for remapping of airfield types, will be populated
  // with content from configuration file
  QMap<QString, QString> c_icaoMap;  // remapping by icao identifiers
  QMap<QString, QString> c_shortMap; // remapping by short names

  // country filter list from configuration file
  QStringList c_countryList;
  // radius around home position
  double c_homeRadius;
  float c_runwayLengthFilter;

  // header data members of compiled file
  quint32 h_magic;
  qint8 h_fileType;
  quint16 h_fileVersion;
  QDateTime h_creationDateTime;
  QStringList h_countryList;
  double h_homeRadius;
  float h_runwayLengthFilter;
  QPoint h_homeCoord;
  QRect h_boundingBox;
  bool h_outlandings; // Flag to indicate outlandings contained or not
  ProjectionBase *h_projection;
  bool h_headerIsValid;

  /** Mutex to ensure thread safety. */
  static QMutex mutex;
};

/******************************************************************************/

#include <QThread>

/**
* \class Welt2000Thread
*
* \author Axel Pauli
*
* \brief Class to read a Welt2000 file in an extra thread.
*
* This class can read, parse and filter a Welt2000 file and store its content
* in a binary format. All work is done in an extra thread. The results are
* returned via the signal \ref loadedLists.
*
* \date 2011
*
* \version $Id$
*/

class Welt2000Thread : public QThread
{
  Q_OBJECT

 public:

  Welt2000Thread( QObject *parent = 0 );

  virtual ~Welt2000Thread();

 protected:

  /**
   * That is the main method of the thread.
   */
  void run();

 signals:

  /**
  * This signal emits the results of the Welt2000 load. The receiver slot is
  * responsible to delete the dynamic allocated lists in every case.
  *
  * \param ok              The result of the load action.
  * \param airfieldList    The list with the airfield data
  * \param gliderfieldList The list with the gliderfield data
  * \param outlandingList  The list with the outlanding data
  *
  */
  void loadedLists( bool ok,
                    QList<Airfield>* airfieldList,
                    QList<Airfield>* gliderfieldList,
                    QList<Airfield>* outlandingList );

};

#endif // _welt2000_h
